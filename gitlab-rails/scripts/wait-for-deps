#!/bin/bash

WAIT_FOR_TIMEOUT="${WAIT_FOR_TIMEOUT:-5}"

# Configure for which schema to be verifying
SCHEMA_FILE=db/structure.sql
SCHEMA_VERSION_DIR=db/schema_migrations
SCHEMA_RAKE_TASK=db:version
SCHEMA_FORMAT=sql
DATABASE_FILE=database.yml

cd /srv/gitlab

# Retain support for older schema if needed
if [ ! -f "db/structure.sql" ]; then
  SCHEMA_FILE=db/schema.rb
  SCHEMA_FORMAT=ruby
fi

if [ "${DB_SCHEMA_TARGET,,}" == "geo" ]; then
  SCHEMA_FILE=ee/db/geo/schema.rb
  SCHEMA_FORMAT=ruby
  DATABASE_FILE=database_geo.yml
fi

# fetch the schema desired version directly from the source code
if [ "${SCHEMA_FORMAT,,}" == "ruby" ]; then
  SCHEMA_VERSION=$(grep '(version: ' ${SCHEMA_FILE} | sed -e 's/_//g' -e 's/.* \([[:digit:]]\+\)) do/\1/')
elif [ ! -d ${SCHEMA_VERSION_DIR} ]; then
  SCHEMA_VERSION=$(sed -n '/COPY "schema_migrations" (version) FROM STDIN/,/\\\./p' ${SCHEMA_FILE} | grep -o "[[:digit:]]*" | awk -v max=0 '{if($1>max){max=$1}}END{print max}')
else
  SCHEMA_VERSION=$(ls -r -1 ${SCHEMA_VERSION_DIR} | head -1)
fi

# Stash DB_SCHEMA_VERSION, so we can check it at exit.
DB_SCHEMA_VERSION="0"

# Compare desired schema version to active schema version in the database
# - set BYPASS_SCHEMA_VERSION to skip version check, and only test DB online
function checkSchemaVersion() {
    # Ask for the current DB schema version, via the schema_migrations table
    SCHEMA_QUERY="SELECT schema_migrations.version FROM schema_migrations ORDER BY schema_migrations.version DESC LIMIT 1"
    DB_SCHEMA_VERSION=$(/scripts/rails-pg-env ${DATABASE_FILE} psql -Atc "${SCHEMA_QUERY}")
    PG_EXIT=$?
    # If psql failed: DB_SCHEMA_VERSION will be empty ('')
    # - 2: could not connect to the DB (host, port, auth, dbname)
    # - 1: 'schema_migrations' table is not present
    # - 0: "All is well *enough*"
    if [ $PG_EXIT -eq 2 ]; then
      return 2
    fi

    DB_SCHEMA_VERSION=${DB_SCHEMA_VERSION:-0}

    # Output the current schema version
    echo "Database Schema - current: ${DB_SCHEMA_VERSION}, codebase: ${SCHEMA_VERSION}"

    # If DB_SCHEMA_VERSION is 0, then the DB has not been initialized. Output message as such.
    if [ "${DB_SCHEMA_VERSION}" == "0" ]; then
      echo "NOTICE: Database has not been initialized yet."
    fi

    # Some uses (migrations) only care if the DB is up
    if [ -n "${BYPASS_SCHEMA_VERSION}" ]; then
      return 0
    fi

    # Compare local to db, pass if local less than or equal to db
    [ $SCHEMA_VERSION -le $DB_SCHEMA_VERSION ];
    return $?
}

function checkRedisConnectivity() {
  echo "Checking Redis connectivity"
  redis_files=(
      resque.yml
      redis.cache.yml
      redis.queues.yml
      redis.shared_state.yml
  )
  for x in $redis_files ; do
    if [ -f /srv/gitlab/config/$x ]; then
      echo "  - checking $x"
      /scripts/rails-redis-ping $x
      if [ $? -ne 0 ]; then
        return 1
      else
        echo "    GOOD"
      fi
    fi
  done
  return 0
}


for i in $(seq 1 $WAIT_FOR_TIMEOUT); do
  echo "Checking database connection and schema version"
  if checkSchemaVersion ; then
    if checkRedisConnectivity ; then
      if [ "$@" ]; then
        exec "$@"
      else
        exit 0
      fi
    fi
  fi
  sleep 1
done

# If DB_SCHEMA_VERSION is 0, then the DB has not been initialized.
# Warn that we're restarting the container whilst we wait.
if [ "${DB_SCHEMA_VERSION}" == "0" ]; then
  echo "WARNING: Database has not been initialized yet."
else
  echo "WARNING: Waiting for all services to be operational, and data migrations to complete."
fi

# Output a message as to how to resolve this container failing.
echo "If this container continues to fail / restart, please see:"
echo "  https://docs.gitlab.com/charts/troubleshooting/index.html#application-containers-constantly-initializing"

exit 1
