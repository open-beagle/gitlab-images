#!/usr/bin/env ruby

require 'fileutils'
require 'open3'

class String
  def red; "\e[31m#{self}\e[0m" end
  def green; "\e[32m#{self}\e[0m" end
  def blue; "\e[34m#{self}\e[0m" end
end

def restore(registry_tar_path)
  puts "Restoring registry ...".blue
  abort("registry_tar_path needs to be passed") unless registry_tar_path

  backup_existing_registry
  cleanup_registry
  restore_from_backup(registry_tar_path)
end

def failure_abort(error_message)
  puts "[Error] #{error_message}".red
  abort 'Restore registry failed'
end

def upload_to_object_storage(source_path, destination_s3_path)
  cmd = %W(s3cmd sync #{source_path} #{destination_s3_path})

  output, status = run_cmd(cmd)

  failure_abort(output) unless status.zero?
end

def backup_existing_registry
  backup_file_name = "registry.#{Time.now.to_i}"
  cmd = %W(s3cmd sync s3://registry s3://tmp/#{backup_file_name}/)
  output, status = run_cmd(cmd)

  failure_abort(output) unless status.zero?
end

def cleanup_registry
  cmd = %w(s3cmd del --force --recursive s3://registry)
  output, status = run_cmd(cmd)
  failure_abort(output) unless status.zero?
end

def restore_from_backup(registry_tar_path)
  extracted_tar_path = File.join(File.dirname(registry_tar_path), '/tmp')
  FileUtils.mkdir_p(extracted_tar_path, mode: 0700)

  failure_abort("#{registry_tar_path} not found") unless File.exist?(registry_tar_path)

  untar_cmd = %W(tar -xf #{registry_tar_path} -C #{extracted_tar_path})

  output, status = run_cmd(untar_cmd)

  failure_abort(output) unless status.zero?

  upload_to_object_storage("#{extracted_tar_path}/docker", "s3://registry")
end

def run_cmd(cmd)
  _, stdout, wait_thr = Open3.popen2e(*cmd)
  return stdout.read, wait_thr.value.exitstatus
end

abort("registry_tar_path needs to be passed as an argument to the script") unless ARGV.length

restore ARGV[0]
puts "done".green
